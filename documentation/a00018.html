---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Rendering </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Much of the rendering functionality in Urho3D is built on two subsystems, <a class="el" href="a00139.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> and <a class="el" href="a00239.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a>.</p>
<h1><a class="anchor" id="Rendering_Graphics"></a>
Graphics</h1>
<p><a class="el" href="a00139.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> implements the low-level functionality:</p>
<ul>
<li>Creating the window and the rendering context</li>
<li>Setting the screen mode</li>
<li>Keeping track of GPU resources</li>
<li>Keeping track of rendering context state (current rendertarget, vertex and index buffers, textures, shaders and renderstates)</li>
<li>Performing primitive rendering operations</li>
<li>Handling lost device</li>
</ul>
<p>Screen resolution, fullscreen/windowed, vertical sync and hardware multisampling level are all set at once by calling <a class="el" href="a00139.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a>'s <a class="el" href="a00139.html#adc16c8a19af1584c902fe29e3d21d6eb">SetMode()</a> function. There is also an experimental option of rendering to an existing window by passing its OS-specific handle to <a class="el" href="a00139.html#abb1c387ef3e39d11a19066f12c420cc6">SetExternalWindow()</a> before setting the initial screen mode.</p>
<p>When setting the initial screen mode, <a class="el" href="a00139.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> does a few checks:</p>
<ul>
<li>For Direct3D9, the supported shader model is checked. 2 is minimum, but 3 will be used if available. SM2 can be forced by calling <a class="el" href="a00139.html#a88b8eb411b824937171647ea4d74d4c6">SetForceSM2()</a> before setting the initial screen mode.</li>
<li>For OpenGL, version 2.0 with EXT_framebuffer_object, EXT_packed_depth_stencil and EXT_texture_filter_anisotropic extensions is checked for.</li>
<li>Is hardware instancing supported? This requires Shader Model 3 on Direct3D9 and the ARB_instanced_arrays extension on OpenGL.</li>
<li>Are hardware shadow maps supported? Both ATI &amp; NVIDIA style shadow maps can be used. If neither are available, no shadows will be rendered.</li>
<li>Are light pre-pass and deferred rendering modes supported? These require sufficient multiple rendertarget support, and R32F texture format support.</li>
</ul>
<h1><a class="anchor" id="Rendering_Renderer"></a>
Renderer</h1>
<p><a class="el" href="a00239.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a> implements the actual rendering of 3D views each frame, and controls global settings such as texture quality, material quality, specular lighting and shadow map base resolution.</p>
<p>To render, it needs a <a class="el" href="a00251.html" title="Root scene node, represents the whole scene.">Scene</a> with an <a class="el" href="a00207.html" title="Octree component. Should be added only to the root scene node">Octree</a> component, and a <a class="el" href="a00079.html" title="Camera component.">Camera</a> that does not necessarily have to belong to the scene. The octree stores all visible components (derived from <a class="el" href="a00117.html" title="Base class for visible components.">Drawable</a>) to allow querying for them in an accelerated manner. The needed information is collected in a <a class="el" href="a00325.html" title="Viewport definition either for a render surface or the backbuffer.">Viewport</a> object, which can be assigned with <a class="el" href="a00239.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a>'s <a class="el" href="a00239.html#a0ea48bfca77a69f1d2f4e2182c0e6a50">SetViewport()</a> function.</p>
<p>By default there is one viewport, but the amount can be increased with the function <a class="el" href="a00239.html#a22da80417d1fe5b0bedd955b9fe836cf">SetNumViewports()</a>. The viewport(s) should cover the entire screen or otherwise hall-of-mirrors artifacts may occur. By specifying a zero screen rectangle the whole window will be used automatically. The viewports will be rendered in ascending order, so if you want for example to have a small overlay window on top of the main viewport, use viewport index 0 for the main view, and 1 for the overlay.</p>
<p>Viewports can also be defined for rendertarget textures. See <a class="el" href="a00028.html">Auxiliary views</a> for details.</p>
<p>Each viewport defines a command sequence for rendering the scene, the <a class="el" href="a00023.html">render path</a>. By default there exist forward, light pre-pass and deferred render paths in the Bin/CoreData/RenderPaths directory, see <a class="el" href="a00239.html#a0e9a7903978c7f793a95a3eedd93d370">SetDefaultRenderPath()</a> to set the default for new viewports. If not overridden from the command line, forward rendering is the default. Deferred rendering modes will be advantageous once there is a large number of per-pixel lights affecting each object, but their disadvantages are the lack of hardware multisampling and inability to choose the lighting model per material. In place of multisample antialiasing, a FXAA post-processing edge filter can be used, see the MultipleViewports sample application (Bin/Data/Scripts/09_MultipleViewports.as) for an example of how to use.</p>
<p>The steps for rendering each viewport on each frame are roughly the following:</p>
<ul>
<li>Query the octree for visible objects and lights in the camera's view frustum.</li>
<li>Check the influence of each visible light on the objects. If the light casts shadows, query the octree for shadowcaster objects.</li>
<li>Construct render operations (batches) for the visible objects, according to the scene passes in the render path command sequence.</li>
<li>Perform the render path command sequence during the rendering step at the end of the frame.</li>
</ul>
<p>In the default render paths, the rendering operations proceed in the following order:</p>
<ul>
<li>Opaque geometry ambient pass, or G-buffer pass in deferred rendering modes.</li>
<li>Opaque geometry per-pixel lighting passes. For shadow casting lights, the shadow map is rendered first.</li>
<li>(Light pre-pass only) Opaque geometry material pass, which renders the objects with accumulated per-pixel lighting.</li>
<li>Pre-alpha rendering pass for custom render ordering such as the skybox.</li>
<li>Transparent geometry rendering pass. Transparent, alpha-blended objects are sorted according to distance and rendered back-to-front to ensure correct blending.</li>
<li>Post-alpha rendering pass.</li>
</ul>
<h1><a class="anchor" id="Rendering_Drawable"></a>
Rendering components</h1>
<p>The rendering-related components defined by the Graphics and UI libraries are:</p>
<ul>
<li><a class="el" href="a00207.html" title="Octree component. Should be added only to the root scene node">Octree</a>: spatial partitioning of Drawables for accelerated visibility queries. Needs to be created to the <a class="el" href="a00251.html" title="Root scene node, represents the whole scene.">Scene</a> (root node.)</li>
<li><a class="el" href="a00079.html" title="Camera component.">Camera</a>: describes a viewpoint for rendering, including projection parameters (FOV, near/far distance, perspective/orthographic)</li>
<li><a class="el" href="a00117.html" title="Base class for visible components.">Drawable</a>: Base class for anything visible.</li>
<li><a class="el" href="a00286.html" title="Static model component.">StaticModel</a>: non-skinned geometry. Can LOD transition according to distance.</li>
<li><a class="el" href="a00288.html" title="Renders several object instances while culling and receiving light as one unit. Can be used as a CPU-...">StaticModelGroup</a>: renders several object instances while culling and receiving light as one unit.</li>
<li><a class="el" href="a00274.html" title="Static model component with fixed position in relation to the camera.">Skybox</a>: a subclass of <a class="el" href="a00286.html" title="Static model component.">StaticModel</a> that appears to always stay in place.</li>
<li><a class="el" href="a00050.html" title="Animated model component.">AnimatedModel</a>: skinned geometry that can do skeletal and vertex morph animation.</li>
<li><a class="el" href="a00053.html" title="Component that drives an AnimatedModel&#39;s animations.">AnimationController</a>: drives animations forward automatically and controls animation fade-in/out.</li>
<li><a class="el" href="a00073.html" title="Billboard component.">BillboardSet</a>: a group of camera-facing billboards, which can have varying sizes, rotations and texture coordinates.</li>
<li><a class="el" href="a00217.html" title="Particle emitter component.">ParticleEmitter</a>: a subclass of <a class="el" href="a00073.html" title="Billboard component.">BillboardSet</a> that emits particle billboards.</li>
<li><a class="el" href="a00161.html" title="Light component.">Light</a>: illuminates the scene. Can optionally cast shadows.</li>
<li><a class="el" href="a00293.html" title="Heightmap terrain component.">Terrain</a>: renders heightmap terrain.</li>
<li><a class="el" href="a00104.html" title="Custom geometry component.">CustomGeometry</a>: renders runtime-defined unindexed geometry. The geometry data is not serialized or replicated over the network.</li>
<li><a class="el" href="a00110.html" title="Decal renderer component.">DecalSet</a>: renders decal geometry on top of objects.</li>
<li><a class="el" href="a00336.html" title="Component that describes global rendering properties">Zone</a>: defines ambient light and fog settings for objects inside the zone volume.</li>
<li><a class="el" href="a00296.html" title="3D text component.">Text3D</a>: text that is rendered into the 3D view.</li>
</ul>
<h1><a class="anchor" id="Rendering_Optimizations"></a>
Optimizations</h1>
<p>The following techniques will be used to reduce the amount of CPU and GPU work when rendering. By default they are all on:</p>
<ul>
<li>Software rasterized occlusion: after the octree has been queried for visible objects, the objects that are marked as occluders are rendered on the CPU to a small hierarchical-depth buffer, and it will be used to test the non-occluders for visibility. Use <a class="el" href="a00239.html#a6f8f74b8fdee7f55b1ecc128141eb176">SetMaxOccluderTriangles()</a> and <a class="el" href="a00239.html#a3fcccde75cf5c79fcc05180a60eb44d8">SetOccluderSizeThreshold()</a> to configure the occlusion rendering.</li>
</ul>
<ul>
<li>Hardware instancing: rendering operations with the same geometry, material and light will be grouped together and performed as one draw call. Objects with a large amount of triangles will not be rendered as instanced, as that could actually be detrimental to performance. Use <a class="el" href="a00239.html#a24957792f7933a93d47f3b63a1b69db7">SetMaxInstanceTriangles()</a> to set the threshold. Note that even when instancing is not available, or the triangle count of objects is too large, they still benefit from the grouping, as render state only needs to be set once before rendering each group, reducing the CPU cost.</li>
</ul>
<ul>
<li>Light stencil masking: in forward rendering, before objects lit by a spot or point light are re-rendered additively, the light's bounding shape is rendered to the stencil buffer to ensure pixels outside the light range are not processed.</li>
</ul>
<p>Note that many more optimization opportunities are possible at the content level, for example using geometry &amp; material LOD, grouping many static objects into one object for less draw calls, minimizing the amount of subgeometries (submeshes) per object for less draw calls, using texture atlases to avoid render state changes, using compressed (and smaller) textures, and setting maximum draw distances for objects, lights and shadows.</p>
<h1><a class="anchor" id="Rendering_GPUResourceLoss"></a>
Handling GPU resource loss</h1>
<p>On Direct3D9 and Android OpenGL ES 2.0 it is possible to lose the rendering context (and therefore GPU resources) due to the application window being minimized to the background. Also, to work around possible GPU driver bugs the desktop OpenGL context will be voluntarily destroyed and recreated when changing screen mode or toggling between fullscreen and windowed. Therefore, on all graphics APIs one must be prepared for losing GPU resources.</p>
<p>Textures that have been loaded from a file, as well as vertex &amp; index buffers that have shadowing enabled will restore their contents automatically, the rest have to be restored manually. On Direct3D9 non-dynamic (managed) textures and buffers will never be lost, as the runtime automatically backs them up to system memory.</p>
<p>See <a class="el" href="a00138.html#afcfd2ec12501214e6f78bb0ce2fee6d5">IsDataLost()</a> function in <a class="el" href="a00321.html" title="Hardware vertex buffer.">VertexBuffer</a>, <a class="el" href="a00151.html" title="Hardware index buffer.">IndexBuffer</a>, <a class="el" href="a00298.html" title="2D texture resource.">Texture2D</a> and <a class="el" href="a00300.html" title="Cube texture resource.">TextureCube</a> classes for detecting data loss. Inbuilt classes such as <a class="el" href="a00185.html" title="3D model resource.">Model</a>, <a class="el" href="a00073.html" title="Billboard component.">BillboardSet</a> and <a class="el" href="a00129.html" title="Font resource.">Font</a> already handle data loss for their internal GPU resources, so checking for it is only necessary for custom buffers and textures. Watch out especially for trying to render with an index buffer that has uninitialized data after a loss, as this can cause a crash inside the GPU driver due to referencing non-existent (garbage) vertices.</p>
<h1><a class="anchor" id="Rendering_Further"></a>
Further details</h1>
<p>See also <a class="el" href="a00021.html">Materials</a>, <a class="el" href="a00022.html">Shaders</a>, <a class="el" href="a00024.html">Lights and shadows</a>, <a class="el" href="a00023.html">Render path</a>, <a class="el" href="a00025.html">Skeletal animation</a>, <a class="el" href="a00026.html">Particle systems</a>, <a class="el" href="a00027.html">Zones</a>, and <a class="el" href="a00028.html">Auxiliary views</a>.</p>
<p>See <a class="el" href="a00019.html">Rendering modes</a> for detailed discussion on the forward, light pre-pass and deferred rendering modes.</p>
<p>See <a class="el" href="a00020.html">Differences between Direct3D9 and OpenGL</a> for what to watch out for when using the low-level rendering functionality directly. </p>
</div></div><!-- contents -->
