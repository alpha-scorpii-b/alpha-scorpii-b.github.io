---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Multithreading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Urho3D uses a task-based multithreading model. The <a class="el" href="a00344.html" title="Work queue subsystem for multithreading.">WorkQueue</a> subsystem can be supplied with tasks described by the <a class="el" href="a00343.html" title="Work queue item.">WorkItem</a> structure, by calling <a class="el" href="a00344.html#a582329d5f6712ee3963315a82e95b40e">AddWorkItem()</a>. These will be executed in background worker threads. The function <a class="el" href="a00344.html#a00cb4ea7cf4dce0e4b2c183bd952e739">Complete()</a> will complete all currently pending tasks, and execute them also in the main thread to make them finish faster.</p>
<p>On single-core systems no worker threads will be created, and tasks are immediately processed by the main thread instead. In the presence of more cores, a worker thread will be created for each hardware core except one which is reserved for the main thread. Hyperthreaded cores are not included, as creating worker threads also for them leads to unpredictable extra synchronization overhead.</p>
<p>The work items include a function pointer to call, with the signature</p>
<pre class="fragment">void WorkFunction(const WorkItem* item, unsigned threadIndex)
</pre><p>The thread index ranges from 0 to n, where 0 represents the main thread and n is the number of worker threads created. Its function is to aid in splitting work into per-thread data structures that need no locking. The work item also contains three void pointers: start, end and aux, which can be used to describe a range of sub-work items, and an auxiliary data structure, which may for example be the object that originally queued the work.</p>
<p>Multithreading is so far not exposed to scripts, and is currently used only in a limited manner: to speed up the preparation of rendering views, including lit object and shadow caster queries, occlusion tests and particle system, animation and skinning updates. Raycasts into the <a class="el" href="a00213.html" title="Octree component. Should be added only to the root scene node">Octree</a> are also threaded, but physics raycasts are not.</p>
<p>When making your own work functions, observe that the following things are (at least currently) unsafe and will result in undefined behavior and crashes, if done outside the main thread:</p>
<ul>
<li>Sending events</li>
<li>Using profiler blocks</li>
<li>Modifying scene or <a class="el" href="a00321.html" title="UI subsystem. Manages the graphical user interface.">UI</a> content</li>
<li>Modifying GPU resources</li>
<li>Requesting resources from <a class="el" href="a00255.html" title="Resource cache subsystem. Loads resources on demand and stores them for later access.">ResourceCache</a></li>
<li>Executing script functions </li>
</ul>
</div></div><!-- contents -->
