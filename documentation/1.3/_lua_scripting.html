---
layout: page
title: Documentation
group: 1.3
---
<div id="top">{% comment %}<!-- do not remove this div, it is closed by doxygen! -->{% endcomment %}
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Lua scripting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Lua scripting in Urho3D has its dedicated <a class="el" href="class_urho3_d_1_1_lua_script.html" title="Lua script subsystem.">LuaScript</a> subsystem that must be instantiated before the scripting capabilities can be used. Lua support is not compiled in by default but must be enabled by the CMake build option -DENABLE_LUA=1. For more details see <a class="el" href="_building.html#Build_Options">Build options</a>. Instantiating the subsystem is done like this:</p>
<div class="fragment"><div class="line">context_-&gt;RegisterSubsystem(<span class="keyword">new</span> LuaScript(context_));</div>
</div><!-- fragment --><p>Like AngelScript, Lua scripting supports immediate compiling and execution of single script lines, loading script files and executing procedural functions from them, and instantiating script objects to scene nodes using the <a class="el" href="class_urho3_d_1_1_lua_script_instance.html" title="Lua script object component.">LuaScriptInstance</a> component.</p>
<h2><a class="anchor" id="LuaScripting_Immediate"></a>
Immediate execution</h2>
<p>Use <a class="el" href="class_urho3_d_1_1_lua_script.html#a39ed1d5f808bb0b6249436e7992c68c5">ExecuteString()</a> to compile and run a line of Lua script. This should not be used for performance-critical operations.</p>
<h2><a class="anchor" id="LuaScripting_ScriptFiles"></a>
Script files and functions</h2>
<p>In contrast to AngelScript modules, which exist as separate entities and do not share functions or variables unless explicitly marked shared, in the Lua subsystem everything is loaded and executed in one Lua state, so scripts can naturally access everything loaded so far. To load and execute a Lua script file, call <a class="el" href="class_urho3_d_1_1_lua_script.html#a4417f265c050cc2e1aa8746d6ddca161">ExecuteFile()</a>.</p>
<p>After that, the functions in the script file are available for calling. Use <a class="el" href="class_urho3_d_1_1_lua_script.html#a5dc47465416a7165bba315a350a3b3cf">ExecuteFunction()</a> to call a Lua function. Parameters to the function can be supplied in a VariantVector.</p>
<h2><a class="anchor" id="LuaScripting_ScriptObjects"></a>
Script objects</h2>
<p>By using the <a class="el" href="class_urho3_d_1_1_lua_script_instance.html" title="Lua script object component.">LuaScriptInstance</a> component, Lua script objects can be added to scene nodes. After the component has been created, there are two ways to specify the object to instantiate: either specifying both the script file name and the object class name, in which case the script file is loaded and executed first, or specifying only the class name, in which case the Lua code containing the class definition must already have been executed. An example of creating a script object in C++ from the LuaIntegration sample, where a class called Rotator is instantiated from the script file Rotator.lua:</p>
<div class="fragment"><div class="line">LuaScriptInstance* instance = node-&gt;CreateComponent&lt;LuaScriptInstance&gt;();</div>
<div class="line">instance-&gt;CreateObject(<span class="stringliteral">&quot;LuaScripts/Rotator.lua&quot;</span>, <span class="stringliteral">&quot;Rotator&quot;</span>);</div>
</div><!-- fragment --><p>After instantiation, functions can be <a class="el" href="class_urho3_d_1_1_lua_script_instance.html#a2505b8f40daff4c7cc8b2fbf0afc0875">called</a> on the script object; parameters are again supplied in a VariantVector.</p>
<p>Like their AngelScript counterparts, script object classes can define functions which are automatically called by <a class="el" href="class_urho3_d_1_1_lua_script_instance.html" title="Lua script object component.">LuaScriptInstance</a> for operations like initialization, scene update, or load/save. These functions are listed below. Refer to the <a class="el" href="_scripting.html">AngelScript scripting</a> page for details.</p>
<ul>
<li>void Start()</li>
<li>void Stop()</li>
<li>void Update(timeStep)</li>
<li>void PostUpdate(timeStep)</li>
<li>void FixedUpdate(timeStep)</li>
<li>void FixedPostUpdate(timeStep)</li>
<li>void Save(serializer)</li>
<li>void Load(deserializer)</li>
<li>void WriteNetworkUpdate(serializer)</li>
<li>void ReadNetworkUpdate(deserializer)</li>
<li>void ApplyAttributes()</li>
</ul>
<h2><a class="anchor" id="LuaScripting_Events"></a>
Event handling</h2>
<p>Like in AngelScript, both procedural and object event handling is supported. In procedural event handling the <a class="el" href="class_urho3_d_1_1_lua_script.html" title="Lua script subsystem.">LuaScript</a> subsystem acts as the event receiver on the C++ side, and forwards the event to a Lua function. Use SubscribeToEvent and give the event name and the function to use as the handler. Optionally a specific sender object can be given as the first argument instead. For example, subscribing to the application-wide Update event, and getting its timestep parameter in the event handler function.</p>
<div class="fragment"><div class="line">SubscribeToEvent(<span class="stringliteral">&quot;Update&quot;</span>, <span class="stringliteral">&quot;HandleUpdate&quot;</span>)</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">function HandleUpdate(eventType, eventData)</div>
<div class="line">    local timeStep = eventData:GetFloat(&quot;TimeStep&quot;)</div>
<div class="line">    ...</div>
<div class="line">end</div>
</div><!-- fragment --><p>When subscribing a script object to receive an event, use the form self:SubscribeToEvent instead. The function to use as the handler is given as "ClassName:FunctionName". For example subscribing to the NodeCollision physics event, and getting the participating other scene node and the contact point <a class="el" href="class_urho3_d_1_1_vector_buffer.html" title="Dynamically sized buffer that can be read and written to as a stream.">VectorBuffer</a> in the handler function:</p>
<div class="fragment"><div class="line">CollisionDetector = ScriptObject()</div>
<div class="line"></div>
<div class="line">function CollisionDetector:Start()</div>
<div class="line">    self:SubscribeToEvent(self.node, &quot;NodeCollision&quot;, &quot;CollisionDetector:HandleNodeCollision&quot;)</div>
<div class="line">end</div>
<div class="line"></div>
<div class="line">function CollisionDetector:HandleNodeCollision(eventType, eventData)</div>
<div class="line">    local otherNode = eventData:GetPtr(&quot;Node&quot;, &quot;OtherNode&quot;)</div>
<div class="line">    local contacts = eventData:GetBuffer(&quot;Contacts&quot;)</div>
<div class="line">    ...</div>
<div class="line">end</div>
</div><!-- fragment --><h2><a class="anchor" id="LuaScripting_API"></a>
The script API</h2>
<p>The binding of Urho3D C++ classes is accomplished with the tolua++ library, which for the most part binds the exact same function parameters as C++. Compared to the AngelScript API, you will always have the classes' Get / Set functions available, but in addition convenience properties also exist.</p>
<p>When constructing <a class="el" href="class_urho3_d_1_1_object.html" title="Base class for objects with type identification, subsystem access and event sending/receiving capabil...">Object</a> subclasses, you need to supply the <a class="el" href="class_urho3_d_1_1_context.html" title="Urho3D execution context. Provides access to subsystems, object factories and attributes, and event receivers.">Context</a> pointer as the first parameter. Use the global function GetContext() to get it. Similarly, use eg. GetFileSystem() or GetInput() to access the subsystems.</p>
<p>As seen above from the event handling examples, VariantMap handling has some differences to both C++ and AngelScript. To get a value, supply its key name as a string. To get a pointer to an object, supply first the object type, then the key name.</p>
<p>For the rest of the functions and classes, see the generated <a class="el" href="_lua_script_a_p_i.html">Lua script API reference</a>. Also, look at the Lua counterparts of the sample applications in the Bin/Data/LuaScripts directory and compare them to the C++ and AngelScript versions to familiarize yourself with how things are done on the Lua side. </p>
</div></div><!-- contents -->
