---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Networking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="a00202.html" title="Network subsystem. Manages client-server communications using the UDP protocol.">Network</a> subsystem provides reliable and unreliable UDP messaging using kNet. A server can be created that listens for incoming connections, and client connections can be made to the server. After connecting, code running on the server can assign the client into a scene to enable scene replication, provided that when connecting, the client specified a blank scene for receiving the updates.</p>
<p>Scene replication is one-directional: the server always has authority and sends scene updates to the client at a fixed update rate, by default 30 FPS. The client responds by sending controls updates (buttons, yaw and pitch + possible extra data) also at a fixed rate.</p>
<p>Bidirectional communication between the server and the client can happen either using raw network messages, which are binary-serialized data, or remote events, which operate like ordinary events, but are processed on the receiving end only. Code on the server can send messages or remote events either to one client, all clients assigned into a particular scene, or to all connected clients. In contrast the client can only send messages or remote events to the server, not directly to other clients.</p>
<p>Note that if a particular networked application does not need scene replication, network messages and remote events can also be transmitted without assigning the client to a scene. The Chat example does just that: it does not create a scene either on the server or the client.</p>
<h1><a class="anchor" id="Network_Connecting"></a>
Connecting to a server</h1>
<p>Starting the server and connecting to it both happen through the <a class="el" href="a00202.html" title="Network subsystem. Manages client-server communications using the UDP protocol.">Network</a> subsystem. See <a class="el" href="a00202.html#aab6b2200094f2d2380d37d5d17216bce">StartServer()</a> and <a class="el" href="a00202.html#a75e313f197c4150135e0577b02915bfa">Connect()</a>. A UDP port must be chosen; the examples use the port 1234.</p>
<p>Note the scene (to be used for replication) and identity VariantMap supplied as parameters when connecting. The identity data can contain for example the user name or credentials, it is completely application-specified. The identity data is sent right after connecting and causes the E_CLIENTIDENTITY event to be sent on the server when received. By subscribing to this event, server code can examine incoming connections and accept or deny them. The default is to accept all connections.</p>
<p>After connecting successfully, client code can get the <a class="el" href="a00097.html" title="Connection to a remote network host.">Connection</a> object representing the server connection, see <a class="el" href="a00202.html#add9709e95d9d35b25251d5e41adea622">GetServerConnection()</a>. Likewise, on the server a <a class="el" href="a00097.html" title="Connection to a remote network host.">Connection</a> object will be created for each connected client, and these can be iterated through. This object is used to send network messages or remote events to the remote peer, to assign the client into a scene (on the server only), or to disconnect.</p>
<h1><a class="anchor" id="Network_Replication"></a>
Scene replication</h1>
<p>Network replication of scene content has been implemented in a straightforward manner, using <a class="el" href="a00034.html">attributes</a>. Nodes and components that have been not been created in local mode - see the CreateMode parameter of <a class="el" href="a00205.html#abf5b4b7cb68f7161ebaeb1db0fdc680d">CreateChild()</a> or <a class="el" href="a00205.html#a5e08b7711f478b82f979417b7d3f8794">CreateComponent()</a> - will be automatically replicated. Note that a replicated component created into a local node will not be replicated, as the node's locality is checked first.</p>
<p>The CreateMode translates into two different node and component ID ranges - replicated ID's range from 0x1 to 0xffffff, while local ID's range from 0x1000000 to 0xffffffff. This means there is a maximum of 16777215 replicated nodes or components in a scene.</p>
<p>If the scene was originally loaded from a file on the server, the client will also load the scene from the same file first. In this case all predefined, static objects such as the world geometry should be defined as local nodes, so that they are not needlessly retransmitted through the network during the initial update, and do not exhaust the more limited replicated ID range.</p>
<p>The server can be made to transmit needed resource <a class="el" href="a00222.html">packages</a> to the client. This requires attaching the package files to the <a class="el" href="a00265.html" title="Root scene node, represents the whole scene.">Scene</a> by calling <a class="el" href="a00265.html#adb229515c3873cb6dbafe3ac58ab2053">AddRequiredPackageFile()</a>. On the client, a cache directory for the packages must be chosen before receiving them is possible: see <a class="el" href="a00202.html#a57b30be42b797f89acad15c24e5adcfe">SetPackageCacheDir()</a>.</p>
<p>There are some things to watch out for:</p>
<ul>
<li>After connecting to a server, the client should not create, update or remove non-local nodes or components on its own. However, to create client-side special effects and such, the client can freely manipulate local nodes.</li>
</ul>
<ul>
<li>A node's <a class="el" href="a00205.html#a4b1a508ba21834d35b46da264e915de3">user variables</a> VariantMap will be automatically replicated on a per-variable basis. This can be useful in transmitting data shared by several components, for example the player's score or health.</li>
</ul>
<ul>
<li>To implement interpolation, exponential smoothing of the nodes' rendering transforms is enabled on the client. It can be controlled by two properties of the <a class="el" href="a00265.html" title="Root scene node, represents the whole scene.">Scene</a>, the smoothing constant and the snap threshold. Snap threshold is the distance between network updates which, if exceeded, causes the node to immediately snap to the end position, instead of moving smoothly. See <a class="el" href="a00265.html#a1a98707b3d010c1260553d2465dc1848">SetSmoothingConstant()</a> and <a class="el" href="a00265.html#a8290804ab553ae30abe3d6ad00869e6f">SetSnapThreshold()</a>.</li>
</ul>
<ul>
<li>Position and rotation are <a class="el" href="a00205.html" title="Scene node that may contain components and child nodes.">Node</a> attributes, while linear and angular velocities are <a class="el" href="a00263.html" title="Physics rigid body component.">RigidBody</a> attributes. To cut down on the needed network bandwidth the physics components can be created as local on the server: in this case the client will not see them at all, and will only interpolate motion based on the node's transform changes. Replicating the actual physics components allows the client to extrapolate using its own physics simulation, and to also perform collision detection, though always non-authoritatively.</li>
</ul>
<ul>
<li>By default the physics simulation also performs interpolation to enable smooth motion when the rendering framerate is higher than the physics FPS. This should be disabled on the server scene to ensure that the clients do not receive interpolated and therefore possibly non-physical positions and rotations. See <a class="el" href="a00233.html#a5cfe054879fc8c7f80394b75f08004cb">SetInterpolation()</a>.</li>
</ul>
<ul>
<li><a class="el" href="a00051.html" title="Animated model component.">AnimatedModel</a> does not replicate animation by itself. Rather, <a class="el" href="a00056.html" title="Component that drives an AnimatedModel&#39;s animations.">AnimationController</a> will replicate its command state (such as "fade this animation in, play that animation at 1.5x speed.") To turn off animation replication, create the <a class="el" href="a00056.html" title="Component that drives an AnimatedModel&#39;s animations.">AnimationController</a> as local. To ensure that also the first animation update will be received correctly, always create the <a class="el" href="a00051.html" title="Animated model component.">AnimatedModel</a> component first, then the <a class="el" href="a00056.html" title="Component that drives an AnimatedModel&#39;s animations.">AnimationController</a>.</li>
</ul>
<ul>
<li>Networked attributes can either be in delta update or latest data mode. Delta updates are small incremental changes and must be applied in order, which may cause increased latency if there is a stall in network message delivery eg. due to packet loss. High volume data such as position, rotation and velocities are transmitted as latest data, which does not need ordering, instead this mode simply discards any old data received out of order. Note that node and component creation (when initial attributes need to be sent) and removal can also be considered as delta updates and are therefore applied in order.</li>
</ul>
<ul>
<li>To avoid going through the whole scene when sending network updates, nodes and components explicitly mark themselves for update when necessary. When writing your own replicated C++ components, call <a class="el" href="a00093.html#a8bb866fda8e97e7d7dd92e491b5d5d91">MarkNetworkUpdate()</a> in member functions that modify any networked attribute.</li>
</ul>
<ul>
<li>The server update logic orders replication messages so that parent nodes are created and updated before their children. Remote events are queued and only sent after the replication update to ensure that if they originate from a newly created node, it will already exist on the receiving end. However, it is also possible to specify unordered transmission for a remote event, in which case that guarantee does not hold.</li>
</ul>
<ul>
<li>Nodes have the concept of the <a class="el" href="a00205.html#a46a82aa6e1c19b4c0cb532fb38b6b4c1">owner connection</a> (for example the player that is controlling a specific game object), which can be set in server code. This property is not replicated to the client. Messages or remote events can be used instead to tell the players what object they control.</li>
</ul>
<ul>
<li>At least for now, there is no built-in client-side prediction.</li>
</ul>
<h1><a class="anchor" id="Network_InterestManagement"></a>
Interest management</h1>
<p>Scene replication includes a simple, distance-based interest management mechanism for reducing bandwidth use. To use, create the <a class="el" href="a00203.html" title="Network interest management settings component.">NetworkPriority</a> component to a <a class="el" href="a00205.html" title="Scene node that may contain components and child nodes.">Node</a> you wish to apply interest management to. The component can be created as local, as it is not important to the clients.</p>
<p>This component has three parameters for controlling the update frequency: <a class="el" href="a00203.html#a9f956039f93cce05fac7dc52d84f97aa">base priority</a>, <a class="el" href="a00203.html#a628b3e207766f563b13eaeb3e17f0fc4">distance factor</a>, and <a class="el" href="a00203.html#a1be4a6e204b8b626737ad0cf45097700">minimum priority</a>.</p>
<p>A current priority value is calculated on each server update as "base priority - distance factor * distance." Additionally, it can never go lower than the minimum priority. This value is then added to an update accumulator. Whenever the update accumulator reaches 100.0, the attribute changes to the node and its components are sent, and the accumulator is reset.</p>
<p>The default values are base priority 100.0, distance factor 0.0, and minimum priority 0.0. This means that by default an update is always sent (which is also the case if the node has no <a class="el" href="a00203.html" title="Network interest management settings component.">NetworkPriority</a> component.) Additionally, there is a rule that the node's owner connection always receives updates at full frequency. This rule can be controlled by calling <a class="el" href="a00203.html#a1017aa1b2e13f2822f3ddc8acb45cb7a">SetAlwaysUpdateOwner()</a>.</p>
<p>Calculating the distance requires the client to tell its current observer position (typically, either the camera's or the player character's world position.) This is accomplished by the client code calling <a class="el" href="a00097.html#a976ecc08522836ae6fbca11fdf57b753">SetPosition()</a> on the server connection.</p>
<p>For now, creation and removal of nodes is always sent immediately, without consulting interest management. This is based on the assumption that nodes' motion updates consume the most bandwidth.</p>
<h1><a class="anchor" id="Network_Controls"></a>
Client controls update</h1>
<p>The <a class="el" href="a00104.html" title="Controls sent over the network.">Controls</a> structure is used to send controls information from the client to the server, by default also at 30 FPS. This includes held down buttons, which is an application-defined 32-bit bitfield, floating point yaw and pitch, and possible extra data (for example the currently selected weapon) stored within a VariantMap.</p>
<p>It is up to the client code to ensure they are kept up-to-date, by calling <a class="el" href="a00097.html#af6f9cc80e240c7ceb715bce429703c9d">SetControls()</a> on the server connection. The event E_NETWORKUPDDATE will be sent to remind of the impending update, and the event E_NETWORKUPDATESENT will be sent after the update. The controls can then be inspected on the server side by calling <a class="el" href="a00097.html#a19197bd80872bda59671e36f91fe8b5a">GetControls()</a>.</p>
<p>The controls update message also includes the client's observer position for interest management.</p>
<h1><a class="anchor" id="Network_Messages"></a>
Raw network messages</h1>
<p>All network messages have an integer ID. The first ID you can use for custom messages is 22 (lower ID's are either reserved for kNet's or the Network subsystem's internal use.) Messages can be sent either unreliably or reliably, in-order or unordered. The data payload is simply raw binary data that can be crafted by using for example <a class="el" href="a00339.html" title="Dynamically sized buffer that can be read and written to as a stream.">VectorBuffer</a>.</p>
<p>To send a message to a <a class="el" href="a00097.html" title="Connection to a remote network host.">Connection</a>, use its <a class="el" href="a00097.html#a8d0d9d3817c2eec4a0a1ca465c63b371">SendMessage()</a> function. On the server, messages can also be broadcast to all client connections by calling the <a class="el" href="a00202.html#a616df39554546ab60e0c26481be29ee2">BroadcastMessage()</a> function.</p>
<p>When a message is received, and it is not an internal protocol message, it will be forwarded as the E_NETWORKMESSAGE event. See the Chat example for details of sending and receiving.</p>
<p>For high performance, consider using unordered messages, because for in-order messages there is only a single channel within the connection, and all previous in-order messages must arrive first before a new one can be processed.</p>
<h1><a class="anchor" id="Network_RemoteEvents"></a>
Remote events</h1>
<p>A remote event consists of its event type (name hash), a flag that tells whether it is to be sent in-order or unordered, and the event data VariantMap. It can optionally set to be originate from a specific <a class="el" href="a00205.html" title="Scene node that may contain components and child nodes.">Node</a> in the receiver's scene ("remote node event.")</p>
<p>To send a remote event to a <a class="el" href="a00097.html" title="Connection to a remote network host.">Connection</a>, use its <a class="el" href="a00097.html#a8ac0d94e4c1cce44ad630efe5b394938">SendRemoteEvent()</a> function. To broadcast remote events to several connections at once (server only), use <a class="el" href="a00202.html" title="Network subsystem. Manages client-server communications using the UDP protocol.">Network</a>'s <a class="el" href="a00202.html#a7d3b29bdf0770ba3584d288779e0b1ce">BroadcastRemoteEvent()</a> function.</p>
<p>For safety, allowed remote event types should be registered so that a client can not for example trigger an internal render update event on the server. See <a class="el" href="a00202.html#a9f4cfd09d02c0b1180b6eb4d9e9b7f62">RegisterRemoteEvent()</a>. Similarly to file paths, as long as no remote event types are registered, all are allowed.</p>
<p>Like with ordinary events, in script event types are strings instead of name hashes for convenience.</p>
<p>Remote events will always have the originating connection as a parameter in the event data. Here is how to get it in both C++ and script (in C++, include NetworkEvents.h):</p>
<p>C++: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>RemoteEventData;</div>
<div class="line">Connection* remoteSender = <span class="keyword">static_cast&lt;</span>Connection*<span class="keyword">&gt;</span>(eventData[P_CONNECTION].GetPtr());</div>
</div><!-- fragment --><p>Script: </p>
<div class="fragment"><div class="line">Connection@ remoteSender = eventData[<span class="stringliteral">&quot;Connection&quot;</span>].GetPtr();</div>
</div><!-- fragment --><h1><a class="anchor" id="Network_HttpRequests"></a>
HTTP requests</h1>
<p>In addition to UDP messaging, the network subsystem allows to make HTTP requests. Use the <a class="el" href="a00202.html#aabc1ba9ce8a6d595ea1daca38e662280">MakeHttpRequest()</a> function for this. You can specify the URL, the verb to use (default GET if empty), optional headers and optional post data. The <a class="el" href="a00157.html" title="An HTTP connection with response data stream.">HttpRequest</a> object that is returned acts like a <a class="el" href="a00122.html" title="Abstract stream for reading.">Deserializer</a>, and you can read the response data in suitably sized chunks. After the whole response is read, the connection closes. The connection can also be closed early by allowing the request object to expire. </p>
</div></div><!-- contents -->
