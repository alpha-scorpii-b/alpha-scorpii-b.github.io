---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Shaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Urho3D uses an ubershader-like approach: permutations of each shader will be built with different compilation defines, to produce eg. static or skinned, deferred or forward or shadowed/unshadowed rendering.</p>
<p>The building of these permutations happens on demand: technique and renderpath definition files both refer to shaders and the compilation defines to use with them. In addition the engine will add inbuilt defines related to geometry type and lighting. It is not generally possible to enumerate beforehand all the possible permutations that can be built out of a single shader.</p>
<p>On Direct3D9 compiled shader bytecode is saved to disk in a "Cache" subdirectory next to the shader source code, so that the possibly time-consuming compile can be skipped on the next time the shader permutation is needed. On OpenGL such mechanism is not available.</p>
<h1><a class="anchor" id="Shaders_InbuiltDefines"></a>
Inbuilt compilation defines</h1>
<p>When rendering scene objects, the engine expects certain shader permutations to exist for different geometry types and lighting conditions. These correspond to the following compilation defines:</p>
<p>Vertex shader:</p>
<ul>
<li>NUMVERTEXLIGHTS=1,2,3 or 4: number of vertex lights influencing the object</li>
<li>DIRLIGHT, SPOTLIGHT, POINTLIGHT: a per-pixel forward light is being used. Accompanied by the define PERPIXEL</li>
<li>SPEC: the per-pixel forward light has specular calculations</li>
<li>SHADOW: the per-pixel forward light has shadowing</li>
<li>SKINNED, INSTANCED, BILLBOARD: choosing the geometry type</li>
<li>HEIGHTFOG: object's zone has height fog mode</li>
</ul>
<p>Pixel shader:</p>
<ul>
<li>DIRLIGHT, SPOTLIGHT, POINTLIGHT: a per-pixel forward light is being used. Accompanied by the define PERPIXEL</li>
<li>CUBEMASK: the point light has a cube map mask</li>
<li>SPEC: the per-pixel forward light has specular calculations</li>
<li>SHADOW: the per-pixel forward light has shadowing</li>
<li>LQSHADOW: use low-quality shadowing (1 hardware PCF sample instead of 4)</li>
<li>SHADOWCMP: use manual shadow depth compare, Direct3D9 only for DF16 &amp; DF24 shadow map formats</li>
<li>HEIGHTFOG: object's zone has height fog mode</li>
</ul>
<h1><a class="anchor" id="Shaders_Writing"></a>
Writing shaders</h1>
<p>Shaders must be written separately for HLSL (Direct3D9) and GLSL (OpenGL). The built-in shaders try to implement the same functionality on both shader languages as closely as possible.</p>
<p>To get started with writing your own shaders, start with studying the most basic examples possible: the Basic, Shadow &amp; Unlit shaders. Note the shader include files which bring common functionality, for example Uniforms.hlsl, Samplers.hlsl &amp; Transform.hlsl for HLSL shaders.</p>
<p>Transforming the vertex (which hides the actual skinning, instancing or billboarding process) is a slight hack which uses a combination of macros and functions: it is safest to copy the following piece of code verbatim:</p>
<p>For HLSL: </p>
<div class="fragment"><div class="line">float4x3 modelMatrix = iModelMatrix;</div>
<div class="line">float3 worldPos = GetWorldPos(modelMatrix);</div>
<div class="line">oPos = GetClipPos(worldPos);</div>
</div><!-- fragment --><p>For GLSL: </p>
<div class="fragment"><div class="line">mat4 modelMatrix = iModelMatrix;</div>
<div class="line">vec3 worldPos = GetWorldPos(modelMatrix);</div>
<div class="line">gl_Position = GetClipPos(worldPos);</div>
</div><!-- fragment --><p>On both Direct3D9 and OpenGL the vertex and pixel shaders are written into the same file, and the entrypoint functions must be called VS() and PS(). In OpenGL mode one of these is transformed to the main() function required by GLSL behind the scenes. When compiling a vertex shader, the compilation define "COMPILEVS" is always present, and likewise "COMPILEPS" when compiling a pixel shader. These are heavily used in the shader include files to prevent constructs that are illegal for the "wrong" type of shader, and to reduce compilation time. When compiling for Shader Model 3 on Direct3D9, the compilation define "SM3" is present: this can be used to separate code which would not compile on SM2.</p>
<p>The uniforms must be prefixed in a certain way so that the engine understands them:</p>
<ul>
<li>c for uniform constants, for example cMatDiffColor. The c is stripped when referred to inside the engine, so it would be called "MatDiffColor" in eg. <a class="el" href="a00182.html#a27f2b7dd5a1ab57e0be7f9a30be657ed">SetShaderParameter()</a></li>
<li>s for texture samplers, for example sDiffMap.</li>
</ul>
<p>In GLSL shaders it is important that the samplers are assigned to the correct texture units. If you are using sampler names that are not predefined in the engine like sDiffMap, just make sure there is a number somewhere in the sampler's name and it will be interpreted as the texture unit. For example the terrain shader uses texture units 0-3 in the following way:</p>
<div class="fragment"><div class="line">uniform sampler2D sWeightMap0;</div>
<div class="line">uniform sampler2D sDetailMap1;</div>
<div class="line">uniform sampler2D sDetailMap2;</div>
<div class="line">uniform sampler2D sDetailMap3;</div>
</div><!-- fragment --><h1><a class="anchor" id="Shaders_Migration"></a>
Migration of old shaders</h1>
<p>In Urho3D V1.3 and before an XML description file was used for shaders, which would enumerate the compilation defines used by shaders into named "options" or "variations". The shader would then be referred to with these option names, for example a pixel shader LitSolid_Diff would use the LitSolid source code and the define DIFFMAP. To convert to the current system, look up the defines from the description files and add them directly to the technique or renderpath XML descriptions ("vsdefines" or "psdefines" attributes). Also make sure the shader references ("vs" and "ps" attributes) are just the bare shader names with no underscore or option names attached. Finally, delete the shader XML description files.</p>
<p>GLSL shaders in V1.3 and before used separate .vert and .frag files for the vertex and pixel shader source code. Now these are combined into .glsl files that include both shaders. Include files are likewise merged into .glsl files instead of separate vertex and pixel shader includes. To merge your shader code, append the pixel shader source into the vertex shader source file without the varyings definition (which should already be in the vertex shader code). Merge and fix include statements: change the file extension to .glsl. Note that some include files depend on each other so it is safest to always include Uniforms.glsl and Samplers.glsl first. Finally change the file extension of the vertex shader source file from .vert to .glsl and delete the .frag file. If you have pieces of pixel shader code (for example additional functions or variables) that produce errors when included in the vertex shader compile, wrap these with #ifdef COMPILEPS, and vice versa for vertex shader code.</p>
<h1><a class="anchor" id="Shaders_Precaching"></a>
Shader precaching</h1>
<p>The shader variations that are potentially used by a material technique in different lighting conditions and rendering passes are enumerated at material load time, but because of their large amount, they are not actually compiled or loaded from bytecode before being used in rendering. Especially on OpenGL the compiling of shaders just before rendering can cause hitches in the framerate. To avoid this, used shader combinations can be dumped out to an XML file, then preloaded. See <a class="el" href="a00143.html#a2664f84fe14e6cc7ccd750470427af32">BeginDumpShaders()</a>, <a class="el" href="a00143.html#a8bc0261c882ff0c3bc8fc5f2871eb54c">EndDumpShaders()</a> and <a class="el" href="a00143.html#ab7a91acbf613629e3b95f600b10e6c2a">PrecacheShaders()</a> in the <a class="el" href="a00143.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> subsystem. The command line parameters -ds &lt;file&gt; can be used to instruct the <a class="el" href="a00123.html" title="Urho3D engine. Creates the other subsystems.">Engine</a> to begin dumping shaders automatically on startup.</p>
<p>Note that the used shader variations will vary with graphics settings, for example shadow quality high/low or instancing on/off. </p>
</div></div><!-- contents -->
