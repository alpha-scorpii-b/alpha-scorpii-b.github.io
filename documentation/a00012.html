---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Events </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Urho3D event system allows for data transport and function invocation without the sender and receiver having to explicitly know of each other. Both the event sender and receiver must derive from <a class="el" href="a00247.html" title="Base class for objects with type identification, subsystem access and event sending/receiving capabil...">Object</a>. An event receiver must subscribe to each event type it wishes to receive: one can either subscribe to the event coming from any sender, or from a specific sender. The latter is useful for example when handling events from the user interface elements.</p>
<p>Events themselves do not need to be registered. They are identified by 32-bit hashes of their names. Event parameters (the data payload) are optional and are contained inside a VariantMap, identified by 32-bit parameter name hashes. For the inbuilt Urho3D events, event type (E_UPDATE, E_KEYDOWN, E_MOUSEMOVE etc.) and parameter hashes (P_TIMESTEP, P_DX, P_DY etc.) are defined as constants inside include files such as CoreEvents.h or InputEvents.h.</p>
<p>When subscribing to an event, a handler function must be specified. In C++ these must have the signature void HandleEvent(StringHash eventType, VariantMap&amp; eventData). The HANDLER(className, function) macro helps in defining the required class-specific function pointers. For example:</p>
<div class="fragment"><div class="line">SubscribeToEvent(E_UPDATE, HANDLER(MyClass, MyEventHandler));</div>
</div><!-- fragment --><p>In script events are identified by their string names instead of name hashes (though these are internally converted to hashes.) Script event handlers can either have the same signature as in C++, or a simplified signature void HandleEvent() when event type and parameters are not required. The same event subscription would look like:</p>
<div class="fragment"><div class="line">SubscribeToEvent(<span class="stringliteral">&quot;Update&quot;</span>, <span class="stringliteral">&quot;MyEventHandler&quot;</span>);</div>
</div><!-- fragment --><p>In C++ events must always be handled by a member function. In script procedural event handling is also possible; in this case the <a class="el" href="a00315.html" title="Script file resource.">ScriptFile</a> where the event handler function is located becomes the event receiver. See <a class="el" href="a00016.html">Scripting</a> for more details.</p>
<p>Events can also be unsubscribed from. See <a class="el" href="a00247.html#a153b96c4397e045b2ca2b2d5471d097c">UnsubscribeFromEvent()</a> for details.</p>
<p>To send an event, fill the event parameters (if necessary) and call <a class="el" href="a00247.html#a32020dbf77c196b9777eca479e8abb36">SendEvent()</a>. For example, this (in C++) is how the <a class="el" href="a00153.html" title="Urho3D engine. Creates the other subsystems.">Engine</a> subsystem sends the Update event on each frame. Note how for the inbuilt Urho3D events, the parameter name hashes are always put inside a namespace (the event's name) to prevent name clashes:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>Update;</div>
<div class="line"></div>
<div class="line">VariantMap eventData;</div>
<div class="line">eventData[P_TIMESTEP] = timeStep_;</div>
<div class="line">SendEvent(E_UPDATE, eventData);</div>
</div><!-- fragment --><p>In script event parameters, like event types, are referred to with strings, so the same code would look like:</p>
<div class="fragment"><div class="line">VariantMap eventData;</div>
<div class="line">eventData[<span class="stringliteral">&quot;TimeStep&quot;</span>] = timeStep;</div>
<div class="line">SendEvent(<span class="stringliteral">&quot;Update&quot;</span>, eventData);</div>
</div><!-- fragment --><h1><a class="anchor" id="Events_AnotherObject"></a>
Sending events through another object</h1>
<p>Because the <a class="el" href="a00247.html#a32020dbf77c196b9777eca479e8abb36">SendEvent()</a> function is public, an event can be "masqueraded" as originating from any object, even when not actually sent by that object's member function code. This can be used to simplify communication, particularly between components in the scene. For example, the <a class="el" href="a00031.html">physics simulation</a> signals collision events by using the participating <a class="el" href="a00242.html">scene nodes</a> as senders. This means that any component can easily subscribe to its own node's collisions without having to know of the actual physics components involved. The same principle can also be used in any game-specific messaging, for example making a "damage received" event originate from the scene node, though it itself has no concept of damage or health. </p>
</div></div><!-- contents -->
