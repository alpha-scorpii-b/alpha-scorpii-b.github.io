---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Input </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="a00189.html" title="Input subsystem. Converts operating system window messages to input state and events.">Input</a> subsystem provides keyboard, mouse, joystick and touch input both via a polled interface and events. This subsystem is also used for querying whether the application window has input focus or is minimized.</p>
<p>The subsystem is always instantiated, even in headless mode, but is active only once the application window has been created. Once active, the subsystem takes over the operating system mouse cursor. It will be hidden by default, so the <a class="el" href="a00365.html" title="UI subsystem. Manages the graphical user interface.">UI</a> should be used to render a software cursor if necessary. For editor-like applications the operating system cursor can be made visible by calling <a class="el" href="a00189.html#a5a8edc8ee7876348bfa4e95f9d901805">SetMouseVisible()</a>.</p>
<p>The input events include:</p>
<ul>
<li>E_MOUSEBUTTONUP: a mouse button was released.</li>
<li>E_MOUSEBUTTONDOWN: a mouse button was pressed.</li>
<li>E_MOUSEMOVE: the mouse moved.</li>
<li>E_MOUSEWHEEL: the mouse wheel moved.</li>
<li>E_KEYUP: a key was released.</li>
<li>E_KEYDOWN: a key was pressed.</li>
<li>E_TEXTINPUT: a string of translated text input in UTF8 format. May contain a single character or several.</li>
<li>E_JOYSTICKCONNECTED: a joystick was plugged in.</li>
<li>E_JOYSTICKDISCONNECTED: a joystick was disconnected.</li>
<li>E_JOYSTICKBUTTONDOWN: a joystick button was pressed.</li>
<li>E_JOYSTICKBUTTONUP: a joystick button was released.</li>
<li>E_JOYSTICKAXISMOVE: a joystick axis was moved.</li>
<li>E_JOYSTICKHATMOVE: a joystick POV hat was moved.</li>
<li>E_TOUCHBEGIN: a finger touched the screen.</li>
<li>E_TOUCHEND: a finger was lifted from the screen.</li>
<li>E_TOUCHMOVE: a finger moved on the screen.</li>
<li>E_GESTURERECORDED : recording a touch gesture is complete.</li>
<li>E_GESTUREINPUT : a touch gesture was recognized.</li>
<li>E_MULTIGESTURE : a multi-finger pinch/rotation touch gesture is underway.</li>
<li>E_DROPFILE : a file was drag-dropped on the application window.</li>
<li>E_INPUTFOCUS : application input focus or window minimization state changed.</li>
<li>E_MOUSEVISIBLECHANGED : the visibility of the operating system mouse cursor was changed.</li>
<li>E_EXITREQUESTED : application exit was requested (eg. with the window close button.)</li>
</ul>
<h1><a class="anchor" id="InputKeyboard"></a>
Keyboard and mouse input</h1>
<p>Key events include both the symbolic keycode ("Key") that depends on the keyboard layout, the layout- and operating system-independent SDL scancode ("Scancode"), and the true operating system-specific raw keycode ("Raw").</p>
<p>The input polling API differentiates between the initiation of a key/mouse button press, and holding the key or button down. <a class="el" href="a00189.html#a81672eb3d3a9fd640a552169f4e1883e">GetKeyPress()</a> and <a class="el" href="a00189.html#a663bad42c0fe6b58452c5ebba35c72ae">GetMouseButtonPress()</a> return true only for one frame (the initiation) while <a class="el" href="a00189.html#a8995ff227b84083c0b1a9050bb211357">GetKeyDown()</a> and <a class="el" href="a00189.html#aa086b042b00127bc840719c7ddcdf33f">GetMouseButtonDown()</a> return true as long as the key or button is held down. To check whether keys are down or pressed by scancode, use <a class="el" href="a00189.html#a9e12e3cb913761213260a3834ca72c2c">GetScancodeDown()</a> and <a class="el" href="a00189.html#aa679ad234440f984ed55145f81139094">GetScancodePress()</a>. Functions also exist for converting keycodes to scancodes or vice versa, or getting key names. See for example <a class="el" href="a00189.html#a747e4a29b52a9a7e37d22cfa5ac7b4ca">GetKeyName()</a> and <a class="el" href="a00189.html#a31aa62d65a2049d8d186942fce84dc25">GetKeyFromScancode()</a>.</p>
<p>Mouse motion since the last frame can be accessed with <a class="el" href="a00189.html#abfa92f94aff38abd7963630f2b315237">GetMouseMove()</a>. When the operating system mouse cursor is hidden, it will be kept centered to the application window to allow "endless" movement in any direction, for example for camera control. The cursor position within the window can be queried with <a class="el" href="a00189.html#af1f70542be73799aaf80057a33d5a011">GetMousePosition()</a>, but that should only be used with a visible cursor (when no automatic centering is being done.)</p>
<p>In AngelScript, the polling API is accessed via properties: input.keyDown[], input.keyPress[], input.scancodeDown[], input.scancodePress[], input.mouseButtonDown[], input.mouseButtonPress[], input.mouseMove, input.mousePosition.</p>
<h1><a class="anchor" id="InputJoystick"></a>
Joystick input</h1>
<p>Plugged in joysticks will begin sending input events automatically. Each joystick will be assigned a joystick ID which will be used in subsequent joystick events, as well as for retrieving the <a class="el" href="a00196.html">joystick state</a>. Use <a class="el" href="a00189.html#ac6898985fd3fec14544d5ec9149badff">GetJoystick()</a> to retrieve the joystick state by ID. In case you do not have the ID, you can also use <a class="el" href="a00189.html#afa54cd976f3a1f3c18cd26e154bb3723">GetJoystickByIndex()</a> which uses a zero-based index; see <a class="el" href="a00189.html#a830c24c772338fd28cb6890fada118c6">GetNumJoysticks()</a> for the number of currently connected joysticks. The ID, as well as the joystick name, can be looked up from the joystick state.</p>
<p>If the joystick model is recognized by SDL as a game controller the buttons and axes mappings utilize known constants such as CONTROLLER_BUTTON_A or CONTROLLER_AXIS_LEFTX without having to guess them. Use <a class="el" href="a00196.html#a1b3e7da6efdecf82cb15f2545247695f">IsController()</a> to distinguish between a game controller and an unrecognized joystick.</p>
<p>On platforms that support the accelerometer, it will appear as a "virtual" joystick.</p>
<h1><a class="anchor" id="InputTouch"></a>
Touch input</h1>
<p>On platforms where touch input is available, touch begin/end/move events will be sent, as well as multi-gesture events with pinch/rotation delta values when more than one finger is pressed down. The current finger touches can also be accessed via a polling API: <a class="el" href="a00189.html#a686a8455da0fe54401490095ee4530f1">GetNumTouches()</a> and <a class="el" href="a00189.html#a6608bb7c777f17e38eeb58b8659c1804">GetTouch()</a>.</p>
<p>Touch gestures can be recorded using SDL's inbuilt $1 gesture recognition system. Use <a class="el" href="a00189.html#a38b0e7ff65040113836a5aff8f2d67c5">RecordGesture()</a> to start recording. The following finger movements will be recorded until the finger is lifted, at which point the recording ends and the E_GESTURERECORDED event is sent with the hash ID of the new gesture. The current in-memory gesture(s) can be saved or loaded as binary data using the <a class="el" href="a00189.html#af1b6f778aa35cb388074cae951ad7eb4">SaveGestures()</a>, <a class="el" href="a00189.html#a0953444f35f21d316ccccbfc57a67674">SaveGesture()</a>, <a class="el" href="a00189.html#a535d7082b98dec18b41d36556fd0d849">LoadGestures()</a> functions.</p>
<p>Whenever a recognized gesture is entered by the user, the E_GESTUREINPUT event will be sent. In addition to the ID of the best matched gesture, it contains the center position and an error metric (lower = better.)</p>
<p>Touch input can also emulate a virtual joystick by displaying on-screen buttons. See the function <a class="el" href="a00189.html#a108458dfa956947d861e96c58d269e85">AddScreenJoystick()</a>.</p>
<h1><a class="anchor" id="InputPlatformSpecific"></a>
Platform-specific details</h1>
<p>On platforms that support it (such as Android) an on-screen virtual keyboard can be shown or hidden. When shown, keypresses from the virtual keyboard will be sent as text input events just as if typed from an actual keyboard. Show or hide it by calling <a class="el" href="a00189.html#a9a8e1073c5e29bac46a0183a803d6df4">SetScreenKeyboardVisible()</a>. The <a class="el" href="a00365.html" title="UI subsystem. Manages the graphical user interface.">UI</a> subsystem can also automatically show the virtual keyboard when a <a class="el" href="a00203.html" title="Single-line text editor UI element.">LineEdit</a> element is focused, and hide it when defocused. This behavior can be controlled by calling <a class="el" href="a00365.html#ad589c4fa698684727046bfd1da5e8854">SetUseScreenKeyboard()</a>.</p>
<p>On Windows the user must first touch the screen once before touch input is activated. Trying to record or load touch gestures will fail before that. </p>
</div></div><!-- contents -->
