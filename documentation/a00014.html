---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Scene model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Urho3D's scene model can be described as a component-based scene graph. The <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a> consists of a hierarchy of scene nodes, starting from the root node, which also represents the whole scene. Each <a class="el" href="a00230.html" title="Scene node that may contain components and child nodes.">Node</a> has a 3D transform (position, rotation and scale), a name and an ID, and a freeform VariantMap for <a class="el" href="a00230.html#a4b1a508ba21834d35b46da264e915de3">user variables</a>, but no other functionality.</p>
<h1><a class="anchor" id="SceneModel_Components"></a>
Components</h1>
<p>Rendering 3D objects, sound playback, physics and scripted logic updates are all enabled by creating different <a class="el" href="a00102.html">Components</a> into the nodes by calling <a class="el" href="a00230.html#a5e08b7711f478b82f979417b7d3f8794">CreateComponent()</a>. As with events, in C++ components are identified by type name hashes, and template forms of the component creation and retrieval functions exist for convenience. For example:</p>
<div class="fragment"><div class="line">Light* light = node-&gt;CreateComponent&lt;Light&gt;();</div>
</div><!-- fragment --><p>In script, strings are used to identify component types instead, so the same code would look like: </p>
<div class="fragment"><div class="line">Light@ light = node.CreateComponent(<span class="stringliteral">&quot;Light&quot;</span>);</div>
</div><!-- fragment --><p>Because components are created using <a class="el" href="a00010.html">object factories</a>, a factory must be registered for each component type.</p>
<p>Components created into the <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a> itself have a special role: to implement scene-wide functionality. They should be created before all other components, and include the following:</p>
<ul>
<li><a class="el" href="a00240.html" title="Octree component. Should be added only to the root scene node">Octree</a>: implements spatial partitioning and accelerated visibility queries. Without this 3D objects can not be rendered.</li>
<li><a class="el" href="a00259.html" title="Physics simulation world component. Should be added only to the root scene node.">PhysicsWorld</a>: implements physics simulation. Physics components such as <a class="el" href="a00289.html" title="Physics rigid body component.">RigidBody</a> or <a class="el" href="a00098.html" title="Physics collision shape component.">CollisionShape</a> can not function properly without this.</li>
<li><a class="el" href="a00135.html" title="Debug geometry rendering component. Should be added only to the root scene node.">DebugRenderer</a>: implements debug geometry rendering.</li>
</ul>
<p>"Ordinary" components like <a class="el" href="a00191.html" title="Light component.">Light</a>, <a class="el" href="a00088.html" title="Camera component.">Camera</a> or <a class="el" href="a00331.html" title="Static model component.">StaticModel</a> should not be created directly into the <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a>, but rather into child nodes.</p>
<h1><a class="anchor" id="SceneModel_Identification"></a>
Identification and scene hierarchy</h1>
<p>Unlike nodes, components do not have names; components inside the same node are only identified by their type, and index in the node's component list, which is filled in creation order. See the various overloads of <a class="el" href="a00230.html#a96f75cc225a16978220dd771f76bdb18">GetComponent()</a> or <a class="el" href="a00230.html#a9f096d8f7c61f7be195c5f0e22a60404">GetComponents()</a> for details.</p>
<p>When created, both nodes and components get scene-global integer IDs. They can be queried from the <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a> by using the functions GetNodeByID() and GetComponentByID(). This is much faster than for example doing recursive name-based scene node queries.</p>
<p>There is no inbuilt concept of an entity or a game object; rather it is up to the programmer to decide the node hierarchy, and in which nodes to place any scripted logic. Typically, free-moving objects in the 3D world would be created as children of the root node. Nodes can be created either with or without a name, see <a class="el" href="a00230.html#abf5b4b7cb68f7161ebaeb1db0fdc680d">CreateChild()</a>. Uniqueness of node names is not enforced.</p>
<p>Whenever there is some hierarchical composition, it is recommended (and in fact necessary, because components do not have their own 3D transforms) to create a child node. For example if a character was holding an object in his hand, the object should have its own node, which would be parented to the character's hand bone (also a <a class="el" href="a00230.html" title="Scene node that may contain components and child nodes.">Node</a>.) The exception is the physics <a class="el" href="a00098.html" title="Physics collision shape component.">CollisionShape</a>, which can be offsetted and rotated individually in relation to the node. See <a class="el" href="a00031.html">Physics</a> for more details. Note that <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a>'s own transform is purposefully ignored as an optimization when calculating world derived transforms of child nodes, so changing it has no effect and it should be left as it is (position at origin, no rotation, no scaling.)</p>
<p>Scene nodes can be freely reparented. In contrast components are always created to the node they belong to, and can not be moved between nodes. Both child nodes and components are stored using <a class="el" href="a00312.html" title="Shared pointer template class with intrusive reference counting.">SharedPtr</a> containers; this means that detaching a child node from its parent or removing a component will also destroy it, if no other references to it exist. Both <a class="el" href="a00230.html" title="Scene node that may contain components and child nodes.">Node</a> &amp; <a class="el" href="a00102.html" title="Base class for components. Components can be created to scene nodes.">Component</a> provide the <a class="el" href="a00230.html#a926c3fc7ece12b5c4d0f9d05e54d8b56">Remove()</a> function to accomplish this without having to go through the parent. Note that no operations on the node or component in question are safe after calling that function.</p>
<p>It is also legal to create a <a class="el" href="a00230.html" title="Scene node that may contain components and child nodes.">Node</a> that does not belong to a scene. This is useful for example with a camera moving in a scene that may be loaded or saved, because then the camera will not be saved along with the actual scene, and will not be destroyed when the scene is loaded. However, note that creating geometry, physics or script components to an unattached node, and then moving it into a scene later will cause those components to not work correctly.</p>
<h1><a class="anchor" id="SceneModel_Update"></a>
Scene updates</h1>
<p>A <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a> whose updates are enabled (default) will be automatically updated on each main loop iteration. See <a class="el" href="a00291.html#a44c46009d055c833246a44cfd95db635">SetUpdateEnabled()</a>.</p>
<p>Nodes and components can be excluded from the scene update by disabling them, see <a class="el" href="a00230.html#aebf77521a93e12e059ce1bb953af5c4f">SetEnabled()</a>. Disabling for example a drawable component also makes it invisible, a sound source component becomes inaudible etc. If a node is disabled, all of its components are treated as disabled regardless of their own enable/disable state.</p>
<h1><a class="anchor" id="SceneModel_Logic"></a>
Creating logic functionality</h1>
<p>To implement your game logic you typically either create script objects (when using scripting) or new components (when using C++). Script objects exist in a C++ placeholder component, but can be basically thought of as components themselves. For a simple example to get you started, check the 05_AnimatingScene sample, which creates a Rotator object to scene nodes to perform rotation on each frame update.</p>
<p>Unless you have extremely serious reasons for doing so, you should not subclass the <a class="el" href="a00230.html" title="Scene node that may contain components and child nodes.">Node</a> class in C++ for implementing your own logic. Doing so will theoretically work, but has the following drawbacks:</p>
<ul>
<li>Loading and saving will not work properly without changes. It assumes that the root node is a Scene, and all the child nodes are of the Node class. It will not know how to instantiate your custom subclass.</li>
<li>The Editor does not know how to edit your subclass.</li>
</ul>
<h1><a class="anchor" id="SceneModel_LoadSave"></a>
Loading and saving scenes</h1>
<p>Scenes can be loaded and saved in either binary or XML format; see the functions <a class="el" href="a00291.html#a3676edea862fd8ecd65002295c0ba0a4">Load()</a>, <a class="el" href="a00291.html#aa6bbfff8c7c8268bd000e401a1aae784">LoadXML()</a>, <a class="el" href="a00291.html#a63343dbb7daf9895a684ce0f0a7d771a">Save()</a> and <a class="el" href="a00291.html#aee92f523b17876750c97e041cc8c7a5c">SaveXML()</a>. See <a class="el" href="a00035.html">Serialization</a> for the technical details on how this works. When a scene is loaded, all existing content in it (child nodes and components) is removed first.</p>
<p>Nodes and components that are marked temporary will not be saved. See <a class="el" href="a00303.html#aaa044160c22b374e032ae85c30520f89">SetTemporary()</a>.</p>
<p>To be able to track the progress of loading a (large) scene without having the program stall for the duration of the loading, a scene can also be loaded asynchronously. This means that on each frame the scene loads child nodes until a certain amount of milliseconds has been exceeded. See <a class="el" href="a00291.html#ac45748e080384a7b5c5a36cb34ad2e55">LoadAsync()</a> and <a class="el" href="a00291.html#aaaa435b4ea393c19dee3fd0bc960aa98">LoadAsyncXML()</a>. Use the functions <a class="el" href="a00291.html#abb2996951ef1c7e92e5b4745ec198617">IsAsyncLoading()</a> and <a class="el" href="a00291.html#a4a752062cb0edf73acda03e4848a9111">GetAsyncProgress()</a> to track the loading progress; the latter returns a float value between 0 and 1, where 1 is fully loaded. The scene will not update or render before it is fully loaded.</p>
<h1><a class="anchor" id="SceneModel_Instantiation"></a>
Object prefabs</h1>
<p>Just loading or saving whole scenes is not flexible enough for eg. games where new objects need to be dynamically created. On the other hand, creating complex objects and setting their properties in code will also be tedious. For this reason, it is also possible to save a scene node (and its child nodes, components and attributes) to either binary or XML to be able to instantiate it later into a scene. Such a saved object is often referred to as a prefab. There are three ways to do this:</p>
<ul>
<li>In code by calling <a class="el" href="a00230.html#ac8571a50d18ea2ea8546e12159ef4720">Save()</a> or <a class="el" href="a00230.html#a4213866996208e32c30e8b7de26a40fc">SaveXML()</a> on the <a class="el" href="a00230.html" title="Scene node that may contain components and child nodes.">Node</a> in question.</li>
<li>In the editor, by selecting the node in the hierarchy window and choosing "Save node as" from the "File" menu.</li>
<li>Using the "node" command in AssetImporter, which will save the scene node hierarchy and any models contained in the input asset (eg. a Collada file)</li>
</ul>
<p>To instantiate the saved node into a scene, call <a class="el" href="a00291.html#a1cca9113f43ff1b7517cf036f569ee52">Instantiate()</a> or <a class="el" href="a00291.html#a16c9193018c0cfadaae69961b9132762">InstantiateXML()</a> depending on the format. The node will be created as a child of the <a class="el" href="a00291.html" title="Root scene node, represents the whole scene.">Scene</a> but can be freely reparented after that. Position and rotation for placing the node need to be specified. The NinjaSnowWar example uses XML format for its object prefabs; these exist in the Bin/Data/Objects directory.</p>
<h1><a class="anchor" id="SceneModel_FurtherInformation"></a>
Further information</h1>
<p>For more information on the component-based scene model, see for example <a href="http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/">http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/</a>. Note that the Urho3D scene model is not a pure Entity-Component-System design, which would have the components just as bare data containers, and only systems acting on them. Instead the Urho3D components contain logic of their own, and actively communicate with the systems (such as rendering, physics or script engine) they depend on. </p>
</div></div><!-- contents -->
