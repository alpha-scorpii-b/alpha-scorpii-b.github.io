---
layout: documentation
title: Documentation
group: 1.5
---
<div id="top">{% comment %}<!-- do not remove this div, it is closed by doxygen! -->{% endcomment %}
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Differences between Direct3D and OpenGL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>These differences need to be observed when using the low-level rendering functionality directly. The high-level rendering architecture, including the <a class="el" href="class_urho3_d_1_1_renderer.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a> and <a class="el" href="class_urho3_d_1_1_u_i.html" title="UI subsystem. Manages the graphical user interface.">UI</a> subsystems and the <a class="el" href="class_urho3_d_1_1_drawable.html" title="Base class for visible components.">Drawable</a> subclasses already handle most of them transparently to the user.</p>
<ul>
<li>The post-projection depth range is (0,1) for Direct3D and (-1,1) for OpenGL. The <a class="el" href="class_urho3_d_1_1_camera.html" title="Camera component.">Camera</a> can be queried either for an API-specific or API-independent (Direct3D convention) projection matrix.</li>
</ul>
<ul>
<li>To render with 1:1 texel-to-pixel mapping, on Direct3D9 UV coordinates have to be shifted a half-pixel to the right and down, or alternatively vertex positions can be shifted a half-pixel left and up. The required shift can be queried with the function <a class="el" href="class_urho3_d_1_1_graphics.html#a880b53245f4ef195cbe2b948d367fe4a">GetPixelUVOffset()</a>.</li>
</ul>
<ul>
<li>On Direct3D the depth-stencil surface can be equal or larger in size than the color rendertarget. On OpenGL the sizes must always match. Furthermore, OpenGL can not use the backbuffer depth-stencil surface when rendering to a texture. To overcome these limitations, <a class="el" href="class_urho3_d_1_1_graphics.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> will create correctly sized depth-stencil surfaces on demand whenever a texture is set as a color rendertarget, and a null depth-stencil is specified.</li>
</ul>
<ul>
<li>On Direct3D9 the viewport will be reset to full size when the first color rendertarget is changed. On OpenGL &amp; Direct3D11 this does not happen. To ensure correct operation on both APIs, always use this sequence: first set the rendertargets, then the depth-stencil surface and finally the viewport.</li>
</ul>
<ul>
<li>On OpenGL modifying a texture will cause it to be momentarily set on the first texture unit. If another texture was set there, the assignment will be lost. <a class="el" href="class_urho3_d_1_1_graphics.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> performs a check to not assign textures redundantly, so it is safe and recommended to always set all needed textures before rendering.</li>
</ul>
<ul>
<li>Modifying an index buffer on OpenGL will similarly cause the existing index buffer assignment to be lost. Therefore, always set the vertex and index buffers before rendering.</li>
</ul>
<ul>
<li>Shader resources are stored in different locations depending on the API: bin/CoreData/Shaders/HLSL for Direct3D, and bin/CoreData/Shaders/GLSL for OpenGL.</li>
</ul>
<ul>
<li>To ensure similar UV addressing for render-to-texture viewports on both APIs, on OpenGL texture viewports will be rendered upside down.</li>
</ul>
<p>OpenGL ES 2.0 has further limitations:</p>
<ul>
<li>Of the DXT formats, only DXT1 compressed textures will be uploaded as compressed, and only if the EXT_texture_compression_dxt1 extension is present. Other DXT formats will be uploaded as uncompressed RGBA. ETC1 (Android) and PVRTC (iOS) compressed textures are supported through the .ktx and .pvr file formats.</li>
</ul>
<ul>
<li>Texture formats such as 16-bit and 32-bit floating point are not available. Corresponding integer 8-bit formats will be returned instead.</li>
</ul>
<ul>
<li>Light pre-pass and deferred rendering are not supported due to missing multiple rendertarget support, and limited rendertarget formats.</li>
</ul>
<ul>
<li>Wireframe and point fill modes are not supported.</li>
</ul>
<ul>
<li>Due to texture unit limit (usually 8), point light shadow maps are not supported.</li>
</ul>
<ul>
<li>To reduce fillrate, the stencil buffer is not reserved and the stencil test is not available. As a consequence, the light stencil masking optimization is not used.</li>
</ul>
<ul>
<li>For improved performance, shadow mapping quality is reduced: there is no smooth PCF filtering and directional lights do not support shadow cascades. Consider also using the low shadow quality (1 sample) to avoid dependent texture reads in the pixel shader, which have an especially high performance cost on iOS hardware.</li>
</ul>
<ul>
<li>Custom clip planes are not currently supported.</li>
</ul>
<ul>
<li>3D textures are not currently supported. </li>
</ul>
</div></div><!-- contents -->
