---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Materials </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="a00190.html" title="Describes how to render 3D geometries.">Material</a> and <a class="el" href="a00314.html" title="Material technique. Consists of several passes.">Technique</a> resources define how to render 3D scene geometry. On the disk, they are XML data. Default and example materials exist in the Bin/CoreData/Materials &amp; Bin/Data/Materials subdirectories, and techniques exist in the Bin/CoreData/Techniques subdirectory.</p>
<p>A material defines the textures, shader parameters and culling mode to use, and refers to one or several techniques. A technique defines the actual rendering passes, the shaders to use in each, and all other rendering states such as depth test, depth write, and blending.</p>
<p>A material definition looks like this:</p>
<div class="fragment"><div class="line">&lt;material&gt;</div>
<div class="line">    &lt;technique name=<span class="stringliteral">&quot;TechniqueName&quot;</span> quality=<span class="stringliteral">&quot;q&quot;</span> loddistance=<span class="stringliteral">&quot;d&quot;</span> /&gt;</div>
<div class="line">    &lt;texture unit=<span class="stringliteral">&quot;diffuse|normal|specular|emissive|environment&quot;</span> name=<span class="stringliteral">&quot;TextureName&quot;</span> /&gt;</div>
<div class="line">    &lt;texture ... /&gt;</div>
<div class="line">    &lt;parameter name=<span class="stringliteral">&quot;name&quot;</span> value=<span class="stringliteral">&quot;x y z w&quot;</span> /&gt;</div>
<div class="line">    &lt;parameter ... /&gt;</div>
<div class="line">    &lt;cull value=<span class="stringliteral">&quot;cw|ccw|none&quot;</span> /&gt;</div>
<div class="line">    &lt;shadowcull value=<span class="stringliteral">&quot;cw|ccw|none&quot;</span> /&gt;</div>
<div class="line">    &lt;depthbias constant=<span class="stringliteral">&quot;x&quot;</span> slopescaled=<span class="stringliteral">&quot;y&quot;</span> /&gt;</div>
<div class="line">&lt;/material&gt;</div>
</div><!-- fragment --><p>Several techniques can be defined for different quality levels and LOD distances. Technique quality levels are specified from 0 (low) to 2 (high). When rendering, the highest available technique that does not exceed the <a class="el" href="a00256.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a>'s material quality setting will be chosen, see <a class="el" href="a00256.html#aabb13682895a9c8f0cabec5ae55cb802">SetMaterialQuality()</a>. It is also possible for a technique to require Shader Model 3, in this case it will be skipped on SM2 hardware.</p>
<p>The techniques for different LOD levels and quality settings must appear in a specific order:</p>
<ul>
<li>Most distant &amp; highest quality</li>
<li>...</li>
<li>Most distant &amp; lowest quality</li>
<li>Second most distant &amp; highest quality</li>
<li>...</li>
</ul>
<p>Material shader parameters can be floats or vectors up to 4 components. Matrix parameters are not supported. A built-in ElapsedTime shader parameter is available for implementing material animation effects; it measures the time elapsed in scene updates in seconds.</p>
<p>Default culling mode is counterclockwise. The shadowcull element specifies the culling mode to use in the shadow pass. Note that material's depth bias settings do not apply in the shadow pass; during shadow rendering the light's depth bias is used instead.</p>
<h1><a class="anchor" id="Materials_Textures"></a>
Material textures</h1>
<p>Diffuse maps specify the surface color in the RGB channels. Optionally they can use the alpha channel for blending and alpha testing. They should preferably be compressed to DXT1 (no alpha or 1-bit alpha) or DXT5 (smooth alpha) format.</p>
<p>Normal maps encode the tangent-space surface normal for normal mapping. There are two options for storing normals, which require choosing the correct material technique, as the pixel shader is different in each case:</p>
<ul>
<li>Store as RGB. In this case use the DiffNormal techniques. This is the default used by AssetImporter, to ensure no conversion of normal textures needs to happen.</li>
<li>Store as xGxR, ie. Y-component in the green channel, and X-component in the alpha. In this case use the DiffNormalPacked techniques: Z will be reconstructed in the pixel shader. This encoding lends itself well to DXT5 compression. To convert normal maps to this format, you can use AMD's The Compressonator utility, see <a href="http://developer.amd.com/Resources/archive/ArchivedTools/gpu/compressonator/Pages/default.aspx">http://developer.amd.com/Resources/archive/ArchivedTools/gpu/compressonator/Pages/default.aspx</a></li>
</ul>
<p>Make sure the normal map is oriented correctly: an even surface should have the color value R 0.5 G 0.5 B 1.0.</p>
<p>Specular maps encode the specular surface color as RGB. Note that deferred rendering is only able to use monochromatic specular intensity from the G channel, while forward and light pre-pass rendering use fully colored specular. DXT1 format should suit these textures well.</p>
<p>Textures can have an accompanying XML file which specifies load-time parameters, such as addressing, mipmapping, and number of mip levels to skip on each quality level:</p>
<div class="fragment"><div class="line">&lt;texture&gt;</div>
<div class="line">    &lt;address coord=<span class="stringliteral">&quot;u|v|w&quot;</span> mode=<span class="stringliteral">&quot;wrap|mirror|clamp|border&quot;</span> /&gt;</div>
<div class="line">    &lt;border color=<span class="stringliteral">&quot;r g b a&quot;</span> /&gt;</div>
<div class="line">    &lt;filter mode=<span class="stringliteral">&quot;nearest|bilinear|trilinear|anisotropic|default&quot;</span> /&gt;</div>
<div class="line">    &lt;mipmap enable=<span class="stringliteral">&quot;false|true&quot;</span> /&gt;</div>
<div class="line">    &lt;quality low=<span class="stringliteral">&quot;x&quot;</span> medium=<span class="stringliteral">&quot;y&quot;</span> high=<span class="stringliteral">&quot;z&quot;</span> /&gt;</div>
<div class="line">    &lt;srgb enable=<span class="stringliteral">&quot;false|true&quot;</span> /&gt;</div>
<div class="line">&lt;/texture&gt;</div>
</div><!-- fragment --><p>The sRGB flag controls both whether the texture should be sampled with sRGB to linear conversion, and if used as a rendertarget, pixels should be converted back to sRGB when writing to it. To control whether the backbuffer should use sRGB conversion on write, call <a class="el" href="a00151.html#af80c739184f6f4e7260a282ee4ace9a9">SetSRGB()</a> on the <a class="el" href="a00151.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> subsystem.</p>
<h1><a class="anchor" id="Materials_Techniques"></a>
Techniques and passes</h1>
<p>A technique definition looks like this:</p>
<div class="fragment"><div class="line">&lt;technique vs=<span class="stringliteral">&quot;VertexShaderName&quot;</span> ps=<span class="stringliteral">&quot;PixelShaderName&quot;</span> vsdefines=<span class="stringliteral">&quot;DEFINE1 DEFINE2&quot;</span> psdefines=<span class="stringliteral">&quot;DEFINE3 DEFINE4&quot;</span> sm3=<span class="stringliteral">&quot;false|true&quot;</span> &gt;</div>
<div class="line">    &lt;pass name=<span class="stringliteral">&quot;base|litbase|light|alpha|litalpha|postopaque|refract|postalpha|prepass|material|deferred|depth|shadow&quot;</span></div>
<div class="line">        vs=<span class="stringliteral">&quot;VertexShaderName&quot;</span> ps=<span class="stringliteral">&quot;PixelShaderName&quot;</span> vsdefines=<span class="stringliteral">&quot;DEFINE1 DEFINE2&quot;</span> psdefines=<span class="stringliteral">&quot;DEFINE3 DEFINE4&quot;</span></div>
<div class="line">        lighting=<span class="stringliteral">&quot;unlit|pervertex|perpixel&quot;</span></div>
<div class="line">        blend=<span class="stringliteral">&quot;replace|add|multiply|alpha|addalpha|premulalpha|invdestalpha|subtract|subtractalpha&quot;</span></div>
<div class="line">        depthtest=<span class="stringliteral">&quot;always|equal|less|lessequal|greater|greaterequal&quot;</span></div>
<div class="line">        depthwrite=<span class="stringliteral">&quot;true|false&quot;</span> </div>
<div class="line">        alphamask=<span class="stringliteral">&quot;true|false&quot;</span> /&gt;</div>
<div class="line">    &lt;pass ... /&gt;</div>
<div class="line">    &lt;pass ... /&gt;</div>
<div class="line">&lt;/technique&gt;</div>
</div><!-- fragment --><p>The sm3 attribute in the technique root element allows the technique to specify it requires Shader Model 3 hardware. Omitting it is same as specifying false (works on both SM2 &amp; 3.)</p>
<p>Shaders are referred to by giving the name of a shader without path and file extension. For example "Basic" or "LitSolid". The engine will add the correct path and file extension (Shaders/HLSL/LitSolid.hlsl for Direct3D9, and Shaders/GLSL/LitSolid.glsl for OpenGL) automatically. The same shader source file contains both the vertex and pixel shader. In addition, compilation defines can be specified, which are passed to the shader compiler. For example the define "DIFFMAP" typically enables diffuse mapping in the pixel shader.</p>
<p>Shaders and their compilation defines can be specified on both the technique and pass level. If a pass does not override the default shaders specified on the technique level, it still can specify additional compilation defines to be used. However, if a pass overrides the shaders, then the technique-level defines are not used.</p>
<p>The technique definition does not need to enumerate shaders used for different geometry types (non-skinned, skinned, instanced, billboard) and different per-vertex and per-pixel light combinations. Instead the engine will add certain hardcoded compilation defines for these. See <a class="el" href="a00022.html">Shaders</a> for details.</p>
<p>The purposes of the different passes are:</p>
<ul>
<li>base: Renders ambient light, per-vertex lights and fog for an opaque object.</li>
<li>litbase: Renders the first per-pixel light, ambient light and fog for an opaque object. This is an optional pass for optimization.</li>
<li>light: Renders one per-pixel light's contribution additively for an opaque object.</li>
<li>alpha: Renders ambient light, per-vertex lights and fog for a transparent object.</li>
<li>litalpha: Renders one per-pixel light's contribution additively for a transparent object</li>
<li>postopaque: Custom rendering pass after opaque geometry. Can be used to render the skybox.</li>
<li>refract: Custom rendering pass after postopaque pass. Can sample the viewport texture from the environment texture unit to render refractive objects.</li>
<li>postalpha: Custom rendering pass after transparent geometry.</li>
<li>prepass: Light pre-pass only - renders normals, specular power and depth to the G-buffer.</li>
<li>material: Light pre-pass only - renders opaque geometry final color by combining ambient light, per-vertex lights and per-pixel light accumulation.</li>
<li>deferred: Deferred rendering only - renders ambient light and per-vertex lights to the output rendertarget, and diffuse albedo, normals, specular intensity + power and depth to the G-buffer.</li>
<li>depth: Renders linear depth to a rendertarget for post-processing effects.</li>
<li>shadow: Renders to a hardware shadow map (depth only) for shadow map generation.</li>
</ul>
<p>More custom passes can be defined and referred to in the <a class="el" href="a00023.html">render path definition</a>. For the built-in passes listed above, the lighting shader permutations to load (unlit, per-vertex or per-pixel) are recognized automatically, but for custom passes they need to be explicitly specified. The default is unlit.</p>
<p>The optional "litbase" pass reduces draw call count by combining ambient lighting with the first per-pixel light affecting an object. However, it has intentional limitations to not require too many shader permutations: there must be no vertex lights affecting the object, and the ambient lighting can not have a gradient. In case of excessive overdraw, it is possibly better not to define it, but instead allow the base pass (which is computationally very lightweight) to run first, initializing the Z buffer for later passes.</p>
<p>"Alphamask" is not an actual rendering state, but a hint which tells that the pixel shader will use discard based on alpha. Because this may interfere with the early-Z culling, materials without the alpha masking hint will be drawn first.</p>
<p>The refract pass requires pingponging the scene rendertarget to a texture, but this will not be performed if there is no refractive geometry to render, so there is no unnecessary cost to it. </p>
</div></div><!-- contents -->
