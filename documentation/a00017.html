---
layout: page
title: Documentation
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Lua scripting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Lua scripting in Urho3D has its dedicated <a class="el" href="a00214.html" title="Lua script subsystem.">LuaScript</a> subsystem that must be instantiated before the scripting capabilities can be used. Lua support is not compiled in by default but must be enabled by the CMake build option -DURHO3D_LUA=1. For more details see <a class="el" href="a00001.html#Build_Options">Build options</a>. Instantiating the subsystem is done like this:</p>
<div class="fragment"><div class="line">context_-&gt;RegisterSubsystem(<span class="keyword">new</span> LuaScript(context_));</div>
</div><!-- fragment --><p>Like AngelScript, Lua scripting supports immediate compiling and execution of single script lines, loading script files and executing procedural functions from them, and instantiating script objects to scene nodes using the <a class="el" href="a00215.html" title="Lua script object component.">LuaScriptInstance</a> component.</p>
<h1><a class="anchor" id="LuaScripting_Immediate"></a>
Immediate execution</h1>
<p>Use <a class="el" href="a00214.html#a39ed1d5f808bb0b6249436e7992c68c5">ExecuteString()</a> to compile and run a line of Lua script. This should not be used for performance-critical operations.</p>
<h1><a class="anchor" id="LuaScripting_ScriptFiles"></a>
Script files and functions</h1>
<p>In contrast to AngelScript modules, which exist as separate entities and do not share functions or variables unless explicitly marked shared, in the Lua subsystem everything is loaded and executed in one Lua state, so scripts can naturally access everything loaded so far. To load and execute a Lua script file, call <a class="el" href="a00214.html#a4417f265c050cc2e1aa8746d6ddca161">ExecuteFile()</a>.</p>
<p>After that, the functions in the script file are available for calling. Use <a class="el" href="a00214.html#a6d8e841633661f8d615cc7aafc67a9a2">GetFunction()</a> to get a Lua function by name. This returns a <a class="el" href="a00213.html" title="Lua function.">LuaFunction</a> object, on which you should call <a class="el" href="a00213.html#a360d10b43236de8f922477866e80fed9">BeginCall()</a> first, followed by pushing the function parameters if any, and finally execute the function with <a class="el" href="a00213.html#a10c1b2a030d1763e524b5fd50e4afd8b">EndCall()</a>.</p>
<h1><a class="anchor" id="LuaScripting_ScriptObjects"></a>
Script objects</h1>
<p>By using the <a class="el" href="a00215.html" title="Lua script object component.">LuaScriptInstance</a> component, Lua script objects can be added to scene nodes. After the component has been created, there are two ways to specify the object to instantiate: either specifying both the script file name and the object class name, in which case the script file is loaded and executed first, or specifying only the class name, in which case the Lua code containing the class definition must already have been executed. An example of creating a script object in C++ from the LuaIntegration sample, where a class called Rotator is instantiated from the script file Rotator.lua:</p>
<div class="fragment"><div class="line">LuaScriptInstance* instance = node-&gt;CreateComponent&lt;LuaScriptInstance&gt;();</div>
<div class="line">instance-&gt;CreateObject(<span class="stringliteral">&quot;LuaScripts/Rotator.lua&quot;</span>, <span class="stringliteral">&quot;Rotator&quot;</span>);</div>
</div><!-- fragment --><p>After instantiation, use <a class="el" href="a00215.html#a563529fb2fb702a93512831eef4e5f0f">GetScriptObjectFunction()</a> to get the object's functions by name; calling happens like above.</p>
<p>Like their AngelScript counterparts, script object classes can define functions which are automatically called by <a class="el" href="a00215.html" title="Lua script object component.">LuaScriptInstance</a> for operations like initialization, scene update, or load/save. These functions are listed below. Refer to the <a class="el" href="a00016.html">AngelScript scripting</a> page for details.</p>
<ul>
<li>Start()</li>
<li>Stop()</li>
<li>Update(timeStep)</li>
<li>PostUpdate(timeStep)</li>
<li>FixedUpdate(timeStep)</li>
<li>FixedPostUpdate(timeStep)</li>
<li>Save(serializer)</li>
<li>Load(deserializer)</li>
<li>WriteNetworkUpdate(serializer)</li>
<li>ReadNetworkUpdate(deserializer)</li>
<li>ApplyAttributes()</li>
<li>TransformChanged()</li>
</ul>
<h1><a class="anchor" id="LuaScripting_Events"></a>
Event handling</h1>
<p>Like in AngelScript, both procedural and object event handling is supported. In procedural event handling the <a class="el" href="a00214.html" title="Lua script subsystem.">LuaScript</a> subsystem acts as the event receiver on the C++ side, and forwards the event to a Lua function. Use SubscribeToEvent and give the event name and the function to use as the handler. Optionally a specific sender object can be given as the first argument instead. For example, subscribing to the application-wide Update event, and getting its timestep parameter in the event handler function.</p>
<div class="fragment"><div class="line">SubscribeToEvent(<span class="stringliteral">&quot;Update&quot;</span>, <span class="stringliteral">&quot;HandleUpdate&quot;</span>)</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">function HandleUpdate(eventType, eventData)</div>
<div class="line">    local timeStep = eventData:GetFloat(&quot;TimeStep&quot;)</div>
<div class="line">    ...</div>
<div class="line">end</div>
</div><!-- fragment --><p>When subscribing a script object to receive an event, use the form self:SubscribeToEvent instead. The function to use as the handler is given as "ClassName:FunctionName". For example subscribing to the NodeCollision physics event, and getting the participating other scene node and the contact point <a class="el" href="a00387.html" title="Dynamically sized buffer that can be read and written to as a stream.">VectorBuffer</a> in the handler function. Note that in Lua retrieving an object pointer from a VariantMap requires the object type as the first parameter:</p>
<div class="fragment"><div class="line">CollisionDetector = ScriptObject()</div>
<div class="line"></div>
<div class="line">function CollisionDetector:Start()</div>
<div class="line">    self:SubscribeToEvent(self.node, &quot;NodeCollision&quot;, &quot;CollisionDetector:HandleNodeCollision&quot;)</div>
<div class="line">end</div>
<div class="line"></div>
<div class="line">function CollisionDetector:HandleNodeCollision(eventType, eventData)</div>
<div class="line">    local otherNode = eventData:GetPtr(&quot;Node&quot;, &quot;OtherNode&quot;)</div>
<div class="line">    local contacts = eventData:GetBuffer(&quot;Contacts&quot;)</div>
<div class="line">    ...</div>
<div class="line">end</div>
</div><!-- fragment --><h1><a class="anchor" id="LuaScripting_API"></a>
The script API</h1>
<p>The binding of Urho3D C++ classes is accomplished with the tolua++ library, which for the most part binds the exact same function parameters as C++. Compared to the AngelScript API, you will always have the classes' Get / Set functions available, but in addition convenience properties also exist.</p>
<p>As seen above from the event handling examples, VariantMap handling has some differences to both C++ and AngelScript. To get a value, supply its key name as a string. To get a pointer to an object, supply first the object type, then the key name.</p>
<p>For the rest of the functions and classes, see the generated <a class="el" href="a00008.html">Lua script API reference</a>. Also, look at the Lua counterparts of the sample applications in the Bin/Data/LuaScripts directory and compare them to the C++ and AngelScript versions to familiarize yourself with how things are done on the Lua side.</p>
<h1><a class="anchor" id="LuaScripting_Allocation"></a>
Object allocation &amp; Lua garbage collection</h1>
<p>There are two ways to allocate a C++ object in Lua scripting, which behave differently with respect to Lua's automatic garbage collection:</p>
<p>1) Call object's contructor: </p>
<div class="fragment"><div class="line">local scene = Scene()</div>
</div><!-- fragment --><p> tolua++ will register this C++ object with garbage collection, and Lua will collect it eventually. Do not use this form if you will add the object to an object hierarchy that is kept alive on the C++ side with <a class="el" href="a00324.html" title="Shared pointer template class with intrusive reference counting.">SharedPtr</a>'s, for example child scene nodes or UI child elements. Otherwise the object will be double-deleted, resulting in a crash.</p>
<p>2) Call the new function: </p>
<div class="fragment"><div class="line">local text = Text:<span class="keyword">new</span>()</div>
</div><!-- fragment --><p> When using this form the object will not collected by Lua, so it is safe to pass into C++ object hierarchies. Otherwise, to prevent memory leaks it needs to be deleted manually by calling the delete function on it: </p>
<div class="fragment"><div class="line">text:<span class="keyword">delete</span>()</div>
</div><!-- fragment --><p>When you call the <a class="el" href="a00295.html#a7a8fddc0e1561115c557850f6751f76b">GetFile()</a> function of <a class="el" href="a00295.html" title="Resource cache subsystem. Loads resources on demand and stores them for later access.">ResourceCache</a> from Lua, the file you receive must also be manually deleted like described above once you are done with it. </p>
</div></div><!-- contents -->
